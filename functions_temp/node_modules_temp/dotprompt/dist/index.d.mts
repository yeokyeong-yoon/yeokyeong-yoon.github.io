import * as Handlebars from 'handlebars';

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

type Schema = Record<string, any>;

interface ToolDefinition {
  name: string;
  description?: string;
  inputSchema: Schema;
  outputSchema?: Schema;
}

type ToolArgument = string | ToolDefinition;

interface HasMetadata {
  /** Arbitrary metadata to be used by tooling or for informational purposes. */
  metadata?: Record<string, any>;
}

interface PromptRef {
  name: string;
  variant?: string;
  version?: string;
}

interface PromptData extends PromptRef {
  source: string;
}

interface PromptMetadata<ModelConfig = Record<string, any>> extends HasMetadata {
  /** The name of the prompt. */
  name?: string;
  /** The variant name for the prompt. */
  variant?: string;
  /** The version of the prompt. */
  version?: string;
  /** A description of the prompt. */
  description?: string;
  /** The name of the model to use for this prompt, e.g. `vertexai/gemini-1.0-pro` */
  model?: string;
  /** Names of tools (registered separately) to allow use of in this prompt. */
  tools?: string[];
  /** Definitions of tools to allow use of in this prompt. */
  toolDefs?: ToolDefinition[];
  /** Model configuration. Not all models support all options. */
  config?: ModelConfig;
  /** Configuration for input variables. */
  input?: {
    /** Defines the default input variable values to use if none are provided. */
    default?: Record<string, any>;
    /** Schema definition for input variables. */
    schema?: Schema;
  };

  /** Defines the expected model output format. */
  output?: {
    /** Desired output format for this prompt. */
    format?: string | "json" | "text";
    /** Schema defining the output structure. */
    schema?: Schema;
  };
  /**
   * This field will contain the raw frontmatter as parsed with no additional processing
   * or substitutions. If your implementation requires custom fields they will be available
   * here.
   **/
  raw?: Record<string, any>;
  /**
   * Fields that contain a period will be considered "extension fields" in the frontmatter
   * and will be gathered by namespace. For example, `myext.foo: 123` would be available
   * at `parsedPrompt.ext.myext.foo`. Nested namespaces will be flattened, so `myext.foo.bar: 123`
   * would be available at `parsedPrompt.ext["myext.foo"].bar`.
   */
  ext?: Record<string, Record<string, any>>;
}

interface ParsedPrompt<ModelConfig = Record<string, any>>
  extends PromptMetadata<ModelConfig> {
  /** The source of the template with metadata / frontmatter already removed. */
  template: string;
}

interface EmptyPart extends HasMetadata {
  text?: never;
  data?: never;
  media?: never;
  toolRequest?: never;
  toolResponse?: never;
}

type TextPart = Omit<EmptyPart, "text"> & { text: string };
type DataPart = Omit<EmptyPart, "data"> & { data: Record<string, any> };
type MediaPart = Omit<EmptyPart, "media"> & { media: { url: string; contentType?: string } };
type ToolRequestPart<Input = any> = Omit<EmptyPart, "toolRequest"> & {
  toolRequest: { name: string; input?: Input; ref?: string };
};
type ToolResponsePart<Output = any> = Omit<EmptyPart, "toolResponse"> & {
  toolResponse: { name: string; output?: Output; ref?: string };
};
type PendingPart = EmptyPart & { metadata: { pending: true; [key: string]: any } };
type Part =
  | TextPart
  | DataPart
  | MediaPart
  | ToolRequestPart
  | ToolResponsePart
  | PendingPart;

interface Message extends HasMetadata {
  role: "user" | "model" | "tool" | "system";
  content: Part[];
}

interface Document extends HasMetadata {
  content: Part[];
}

/**
 * DataArgument provides all of the information necessary to render a
 * template at runtime.
 **/
interface DataArgument<Variables = any, State = any> {
  /** Input variables for the prompt template. */
  input?: Variables;
  /** Relevant documents. */
  docs?: Document[];
  /** Previous messages in the history of a multi-turn conversation. */
  messages?: Message[];
  /**
   * Items in the context argument are exposed as `@` variables, e.g.
   * `context: {state: {...}}` is exposed as `@state`.
   **/
  context?: Record<string, any>;
}

type JSONSchema = any;

/**
 * SchemaResolver is a function that can resolve a provided schema name to
 * an underlying JSON schema, utilized for shorthand to a schema library
 * provided by an external tool.
 **/
interface SchemaResolver {
  (schemaName: string): JSONSchema | null | Promise<JSONSchema | null>;
}

/**
 * SchemaResolver is a function that can resolve a provided tool name to
 * an underlying ToolDefinition, utilized for shorthand to a tool registry
 * provided by an external library.
 **/
interface ToolResolver {
  (toolName: string): ToolDefinition | null | Promise<ToolDefinition | null>;
}

/**
 * RenderedPrompt is the final result of rendering a Dotprompt template.
 * It includes all of the prompt metadata as well as a set of `messages` to
 * be sent to the  model.
 */
interface RenderedPrompt<ModelConfig = Record<string, any>>
  extends PromptMetadata<ModelConfig> {
  /** The rendered messages of the prompt. */
  messages: Message[];
}

/**
 * PromptFunction is a function that takes runtime data / context and returns
 * a rendered prompt result.
 */
interface PromptFunction<ModelConfig = Record<string, any>> {
  (data: DataArgument, options?: PromptMetadata<ModelConfig>): Promise<RenderedPrompt<ModelConfig>>;
  prompt: ParsedPrompt<ModelConfig>;
}

/**
 * PromptRefFunction is a function that takes runtime data / context and returns
 * a rendered prompt result after loading a prompt via reference.
 */
interface PromptRefFunction<ModelConfig = Record<string, any>> {
  (data: DataArgument, options?: PromptMetadata<ModelConfig>): Promise<RenderedPrompt<ModelConfig>>;
  promptRef: PromptRef;
}

interface PaginatedResponse {
  cursor?: string;
}

interface PartialRef {
  name: string;
  variant?: string;
  version?: string;
}

interface PartialData extends PartialRef {
  source: string;
}

/**
 * PromptStore is a common interface that provides for
 */
interface PromptStore {
  /** Return a list of all prompts in the store (optionally paginated). Some store providers may return limited metadata. */
  list(options?: {
    cursor?: string;
    limit?: number;
  }): Promise<{ prompts: Array<PromptRef>; cursor?: string }>;
  /** Return a list of partial names available in this store. */
  listPartials(options?: { cursor?: string; limit?: number }): Promise<{
    partials: Array<PartialRef>;
    cursor?: string;
  }>;
  /** Retrieve a prompt from the store.  */
  load(name: string, options?: { variant?: string; version?: string }): Promise<PromptData>;
  /** Retrieve a partial from the store. */
  loadPartial(name: string, options?: { variant?: string; version?: string }): Promise<PromptData>;
}

/**
 * PromptStoreWritable is a PromptStore that also has built-in methods for writing prompts in addition to reading them.
 */
interface PromptStoreWritable extends PromptStore {
  /** Save a prompt in the store. May be destructive for prompt stores without versioning. */
  save(prompt: PromptData): Promise<void>;
  /** Delete a prompt from the store. */
  delete(name: string, options?: { variant?: string }): Promise<void>;
}

interface PromptBundle {
  partials: PartialData[];
  prompts: PromptData[];
}

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Function to resolve partial names to their content */
interface PartialResolver {
    (partialName: string): string | null | Promise<string | null>;
}
interface DotpromptOptions {
    /** A default model to use if none is supplied. */
    defaultModel?: string;
    /** Assign a set of default configuration options to be used with a particular model. */
    modelConfigs?: Record<string, object>;
    /** Helpers to pre-register. */
    helpers?: Record<string, Handlebars.HelperDelegate>;
    /** Partials to pre-register. */
    partials?: Record<string, string>;
    /** Provide a static mapping of tool definitions that should be used when resolving tool names. */
    tools?: Record<string, ToolDefinition>;
    /** Provide a lookup implementation to resolve tool names to definitions. */
    toolResolver?: ToolResolver;
    /** Provide a static mapping of schema names to their JSON Schema definitions. */
    schemas?: Record<string, JSONSchema>;
    /** Provide a lookup implementation to resolve schema names to JSON schema definitions. */
    schemaResolver?: SchemaResolver;
    /** Provide a lookup implementation to resolve partial names to their content. */
    partialResolver?: PartialResolver;
}
declare class Dotprompt {
    private handlebars;
    private knownHelpers;
    private defaultModel?;
    private modelConfigs;
    private tools;
    private toolResolver?;
    private schemas;
    private schemaResolver?;
    private partialResolver?;
    private store?;
    constructor(options?: DotpromptOptions);
    defineHelper(name: string, fn: Handlebars.HelperDelegate): this;
    definePartial(name: string, source: string): this;
    defineTool(def: ToolDefinition): this;
    parse<ModelConfig = Record<string, any>>(source: string): ParsedPrompt<ModelConfig>;
    render<Variables = Record<string, any>, ModelConfig = Record<string, any>>(source: string, data?: DataArgument<Variables>, options?: PromptMetadata<ModelConfig>): Promise<RenderedPrompt<ModelConfig>>;
    private renderPicoschema;
    private wrappedSchemaResolver;
    private resolveMetadata;
    private resolveTools;
    private identifyPartials;
    private resolvePartials;
    compile<Variables = any, ModelConfig = Record<string, any>>(source: string | ParsedPrompt<ModelConfig>, additionalMetadata?: PromptMetadata<ModelConfig>): Promise<PromptFunction<ModelConfig>>;
    renderMetadata<ModelConfig>(source: string | ParsedPrompt<ModelConfig>, additionalMetadata?: PromptMetadata<ModelConfig>): Promise<PromptMetadata<ModelConfig>>;
}

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface PicoschemaOptions {
    schemaResolver?: SchemaResolver;
}
declare function picoschema(schema: unknown, options?: PicoschemaOptions): Promise<any>;
declare class PicoschemaParser {
    schemaResolver?: SchemaResolver;
    constructor(options?: PicoschemaOptions);
    private mustResolveSchema;
    parse(schema: unknown): Promise<JSONSchema | null>;
    private parsePico;
}

export { type DataArgument, type DataPart, type Document, Dotprompt, type DotpromptOptions, type JSONSchema, type MediaPart, type Message, type PaginatedResponse, type ParsedPrompt, type Part, type PartialData, type PartialRef, type PendingPart, type PicoschemaOptions, PicoschemaParser, type PromptBundle, type PromptData, type PromptFunction, type PromptMetadata, type PromptRef, type PromptRefFunction, type PromptStore, type PromptStoreWritable, type RenderedPrompt, type Schema, type SchemaResolver, type TextPart, type ToolArgument, type ToolDefinition, type ToolRequestPart, type ToolResolver, type ToolResponsePart, picoschema };
