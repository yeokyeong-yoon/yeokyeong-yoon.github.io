var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/dotprompt.ts
import * as Handlebars from "handlebars";

// src/helpers.ts
var helpers_exports = {};
__export(helpers_exports, {
  history: () => history,
  ifEquals: () => ifEquals,
  json: () => json,
  media: () => media,
  role: () => role,
  section: () => section,
  unlessEquals: () => unlessEquals
});
import { SafeString } from "handlebars";
function json(serializable, options) {
  return new SafeString(JSON.stringify(serializable, null, options.hash.indent || 0));
}
function role(role2) {
  return new SafeString(`<<<dotprompt:role:${role2}>>>`);
}
function history() {
  return new SafeString("<<<dotprompt:history>>>");
}
function section(name) {
  return new SafeString(`<<<dotprompt:section ${name}>>>`);
}
function media(options) {
  return new SafeString(
    `<<<dotprompt:media:url ${options.hash.url}${options.hash.contentType ? ` ${options.hash.contentType}` : ""}>>>`
  );
}
function ifEquals(arg1, arg2, options) {
  return arg1 == arg2 ? options.fn(this) : options.inverse(this);
}
function unlessEquals(arg1, arg2, options) {
  return arg1 != arg2 ? options.fn(this) : options.inverse(this);
}

// src/parse.ts
import { parse } from "yaml";
var FRONTMATTER_REGEX = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
var RESERVED_METADATA_KEYWORDS = [
  "name",
  "variant",
  "version",
  "description",
  "model",
  "tools",
  "toolDefs",
  "config",
  "input",
  "output",
  "raw",
  "ext"
];
var BASE_METADATA = {
  ext: {},
  metadata: {},
  config: {}
};
function parseDocument(source) {
  const match = source.match(FRONTMATTER_REGEX);
  if (match) {
    const [, frontmatter, content] = match;
    try {
      const parsedMetadata = parse(frontmatter);
      const raw = { ...parsedMetadata };
      const pruned = { ...BASE_METADATA };
      const ext = {};
      for (const k in raw) {
        const key = k;
        if (RESERVED_METADATA_KEYWORDS.includes(key)) {
          pruned[key] = raw[key];
        } else if (key.includes(".")) {
          const lastDotIndex = key.lastIndexOf(".");
          const namespace = key.substring(0, lastDotIndex);
          const fieldName = key.substring(lastDotIndex + 1);
          ext[namespace] = ext[namespace] || {};
          ext[namespace][fieldName] = raw[key];
        }
      }
      return { ...pruned, raw, ext, template: content.trim() };
    } catch (error) {
      console.error("Dotprompt: Error parsing YAML frontmatter:", error);
      return { ...BASE_METADATA, template: source.trim() };
    }
  }
  return { ...BASE_METADATA, template: source };
}
var ROLE_REGEX = /(<<<dotprompt:(?:role:[a-z]+|history))>>>/g;
function toMessages(renderedString, data) {
  let currentMessage = {
    role: "user",
    source: ""
  };
  const messageSources = [currentMessage];
  for (const piece of renderedString.split(ROLE_REGEX).filter((s) => s.trim() !== "")) {
    if (piece.startsWith("<<<dotprompt:role:")) {
      const role2 = piece.substring(18);
      if (currentMessage.source.trim()) {
        currentMessage = { role: role2, source: "" };
        messageSources.push(currentMessage);
      } else {
        currentMessage.role = role2;
      }
    } else if (piece.startsWith("<<<dotprompt:history")) {
      messageSources.push(
        ...data?.messages?.map((m) => {
          return {
            ...m,
            metadata: { ...m.metadata || {}, purpose: "history" }
          };
        }) || []
      );
      currentMessage = { role: "model", source: "" };
      messageSources.push(currentMessage);
    } else {
      currentMessage.source += piece;
    }
  }
  const messages = messageSources.filter((ms) => ms.content || ms.source).map((m) => {
    const out = {
      role: m.role,
      content: m.content || toParts(m.source)
    };
    if (m.metadata) out.metadata = m.metadata;
    return out;
  });
  return insertHistory(messages, data?.messages);
}
function insertHistory(messages, history2 = []) {
  if (!history2 || messages.find((m) => m.metadata?.purpose === "history")) return messages;
  if (messages.at(-1)?.role === "user") {
    return [...messages.slice(0, -1), ...history2, messages.at(-1)];
  }
  return [...messages, ...history2];
}
var PART_REGEX = /(<<<dotprompt:(?:media:url|section).*?)>>>/g;
function toParts(source) {
  const parts = [];
  const pieces = source.split(PART_REGEX).filter((s) => s.trim() !== "");
  for (let i = 0; i < pieces.length; i++) {
    const piece = pieces[i];
    if (piece.startsWith("<<<dotprompt:media:")) {
      const [_, url, contentType] = piece.split(" ");
      const part = { media: { url } };
      if (contentType) part.media.contentType = contentType;
      parts.push(part);
    } else if (piece.startsWith("<<<dotprompt:section")) {
      const [_, sectionType] = piece.split(" ");
      parts.push({ metadata: { purpose: sectionType, pending: true } });
    } else {
      parts.push({ text: piece });
    }
  }
  const apart = { text: "foo" };
  return parts;
}

// src/picoschema.ts
var JSON_SCHEMA_SCALAR_TYPES = ["string", "boolean", "null", "number", "integer", "any"];
var WILDCARD_PROPERTY_NAME = "(*)";
async function picoschema(schema, options) {
  return new PicoschemaParser(options).parse(schema);
}
var PicoschemaParser = class {
  schemaResolver;
  constructor(options) {
    this.schemaResolver = options?.schemaResolver;
  }
  async mustResolveSchema(schemaName) {
    if (!this.schemaResolver) {
      throw new Error(`Picoschema: unsupported scalar type '${schemaName}'.`);
    }
    const val = await this.schemaResolver(schemaName);
    if (!val) {
      throw new Error(`Picoschema: could not find schema with name '${schemaName}'`);
    }
    return val;
  }
  async parse(schema) {
    if (!schema) return null;
    if (typeof schema === "string") {
      const [type, description] = extractDescription(schema);
      if (JSON_SCHEMA_SCALAR_TYPES.includes(type)) {
        let out = { type };
        if (description) out = { ...out, description };
        return out;
      }
      const resolvedSchema = await this.mustResolveSchema(type);
      return description ? { ...resolvedSchema, description } : resolvedSchema;
    }
    if ([...JSON_SCHEMA_SCALAR_TYPES, "object", "array"].includes(schema?.type)) {
      return schema;
    }
    if (typeof schema?.properties === "object") {
      return { ...schema, type: "object" };
    }
    return this.parsePico(schema);
  }
  async parsePico(obj, path = []) {
    if (typeof obj === "string") {
      const [type, description] = extractDescription(obj);
      if (!JSON_SCHEMA_SCALAR_TYPES.includes(type)) {
        let resolvedSchema = await this.mustResolveSchema(type);
        if (description) resolvedSchema = { ...resolvedSchema, description };
        return resolvedSchema;
      }
      if (type === "any") {
        return description ? { description } : {};
      }
      return description ? { type, description } : { type };
    } else if (typeof obj !== "object") {
      throw new Error(
        "Picoschema: only consists of objects and strings. Got: " + JSON.stringify(obj)
      );
    }
    const schema = {
      type: "object",
      properties: {},
      required: [],
      additionalProperties: false
    };
    for (const key in obj) {
      if (key === WILDCARD_PROPERTY_NAME) {
        schema.additionalProperties = await this.parsePico(obj[key], [...path, key]);
        continue;
      }
      const [name, typeInfo] = key.split("(");
      const isOptional = name.endsWith("?");
      const propertyName = isOptional ? name.slice(0, -1) : name;
      if (!isOptional) {
        schema.required.push(propertyName);
      }
      if (!typeInfo) {
        const prop = { ...await this.parsePico(obj[key], [...path, key]) };
        if (isOptional && typeof prop.type === "string") {
          prop.type = [prop.type, "null"];
        }
        schema.properties[propertyName] = prop;
        continue;
      }
      const [type, description] = extractDescription(typeInfo.substring(0, typeInfo.length - 1));
      if (type === "array") {
        schema.properties[propertyName] = {
          type: isOptional ? ["array", "null"] : "array",
          items: await this.parsePico(obj[key], [...path, key])
        };
      } else if (type === "object") {
        const prop = await this.parsePico(obj[key], [...path, key]);
        if (isOptional) prop.type = [prop.type, "null"];
        schema.properties[propertyName] = prop;
      } else if (type === "enum") {
        const prop = { enum: obj[key] };
        if (isOptional && !prop.enum.includes(null)) prop.enum.push(null);
        schema.properties[propertyName] = prop;
      } else {
        throw new Error(
          "Picoschema: parenthetical types must be 'object' or 'array', got: " + type
        );
      }
      if (description) {
        schema.properties[propertyName].description = description;
      }
    }
    if (!schema.required.length) delete schema.required;
    return schema;
  }
};
function extractDescription(input) {
  if (!input.includes(",")) return [input, null];
  const match = input.match(/(.*?), *(.*)$/);
  return [match[1], match[2]];
}

// src/util.ts
function removeUndefinedFields(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => removeUndefinedFields(item));
  }
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (value !== void 0) {
      result[key] = removeUndefinedFields(value);
    }
  }
  return result;
}

// src/dotprompt.ts
var Dotprompt = class {
  handlebars;
  knownHelpers = {};
  defaultModel;
  modelConfigs = {};
  tools = {};
  toolResolver;
  schemas = {};
  schemaResolver;
  partialResolver;
  store;
  constructor(options) {
    this.handlebars = Handlebars.noConflict();
    this.modelConfigs = options?.modelConfigs || this.modelConfigs;
    this.defaultModel = options?.defaultModel;
    this.tools = options?.tools || {};
    this.toolResolver = options?.toolResolver;
    this.schemas = options?.schemas || {};
    this.schemaResolver = options?.schemaResolver;
    this.partialResolver = options?.partialResolver;
    for (const key in helpers_exports) {
      this.defineHelper(key, helpers_exports[key]);
      this.handlebars.registerHelper(key, helpers_exports[key]);
    }
    if (options?.helpers) {
      for (const key in options.helpers) {
        this.defineHelper(key, options.helpers[key]);
      }
    }
    if (options?.partials) {
      for (const key in options.partials) {
        this.definePartial(key, options.partials[key]);
      }
    }
  }
  defineHelper(name, fn) {
    this.handlebars.registerHelper(name, fn);
    this.knownHelpers[name] = true;
    return this;
  }
  definePartial(name, source) {
    this.handlebars.registerPartial(name, source);
    return this;
  }
  defineTool(def) {
    this.tools[def.name] = def;
    return this;
  }
  parse(source) {
    return parseDocument(source);
  }
  async render(source, data = {}, options) {
    const renderer = await this.compile(source);
    return renderer(data, options);
  }
  async renderPicoschema(meta) {
    if (!meta.output?.schema && !meta.input?.schema) return meta;
    const newMeta = { ...meta };
    if (meta.input?.schema) {
      newMeta.input = {
        ...meta.input,
        schema: await picoschema(meta.input.schema, {
          schemaResolver: this.wrappedSchemaResolver.bind(this)
        })
      };
    }
    if (meta.output?.schema) {
      newMeta.output = {
        ...meta.output,
        schema: await picoschema(meta.output.schema, {
          schemaResolver: this.wrappedSchemaResolver.bind(this)
        })
      };
    }
    return newMeta;
  }
  async wrappedSchemaResolver(name) {
    if (this.schemas[name]) return this.schemas[name];
    if (this.schemaResolver) return await this.schemaResolver(name);
    return null;
  }
  async resolveMetadata(base, ...merges) {
    let out = { ...base };
    for (let i = 0; i < merges.length; i++) {
      if (!merges[i]) continue;
      const config = out.config || {};
      out = { ...out, ...merges[i] };
      out.config = { ...config, ...merges[i]?.config || {} };
    }
    delete out.template;
    out = removeUndefinedFields(out);
    out = await this.resolveTools(out);
    out = await this.renderPicoschema(out);
    return out;
  }
  async resolveTools(base) {
    const out = { ...base };
    if (out.tools) {
      const outTools = [];
      out.toolDefs = out.toolDefs || [];
      await Promise.all(
        out.tools.map(async (toolName) => {
          if (this.tools[toolName]) {
            out.toolDefs.push(this.tools[toolName]);
          } else if (this.toolResolver) {
            const resolvedTool = await this.toolResolver(toolName);
            if (!resolvedTool) {
              throw new Error(
                `Dotprompt: Unable to resolve tool '${toolName}' to a recognized tool definition.`
              );
            }
            out.toolDefs.push(resolvedTool);
          } else {
            outTools.push(toolName);
          }
        })
      );
      out.tools = outTools;
    }
    return out;
  }
  identifyPartials(template) {
    const ast = this.handlebars.parse(template);
    const partials = /* @__PURE__ */ new Set();
    class PartialVisitor extends this.handlebars.Visitor {
      constructor(partials2) {
        super();
        this.partials = partials2;
      }
      PartialStatement(partial) {
        if ("original" in partial.name) {
          this.partials.add(partial.name.original);
        }
      }
    }
    new PartialVisitor(partials).accept(ast);
    return partials;
  }
  async resolvePartials(template) {
    if (!this.partialResolver && !this.store) return;
    const partials = this.identifyPartials(template);
    await Promise.all(
      Array.from(partials).map(async (name) => {
        if (!this.handlebars.partials[name]) {
          const content = await this.partialResolver(name) || (await this.store?.loadPartial(name))?.source;
          if (content) {
            this.definePartial(name, content);
            await this.resolvePartials(content);
          }
        }
      })
    );
  }
  async compile(source, additionalMetadata) {
    if (typeof source === "string") source = this.parse(source);
    if (additionalMetadata) source = { ...source, ...additionalMetadata };
    await this.resolvePartials(source.template);
    const renderString = this.handlebars.compile(source.template, {
      knownHelpers: this.knownHelpers,
      knownHelpersOnly: true
    });
    const renderFunc = async (data, options) => {
      const { input, ...mergedMetadata } = await this.renderMetadata(source);
      const renderedString = renderString(
        { ...options?.input?.default || {}, ...data.input },
        {
          data: {
            metadata: { prompt: mergedMetadata, docs: data.docs, messages: data.messages },
            ...data.context || {}
          }
        }
      );
      return {
        ...mergedMetadata,
        messages: toMessages(renderedString, data)
      };
    };
    renderFunc.prompt = source;
    return renderFunc;
  }
  async renderMetadata(source, additionalMetadata) {
    if (typeof source === "string") source = this.parse(source);
    const selectedModel = additionalMetadata?.model || source.model || this.defaultModel;
    const modelConfig = this.modelConfigs[selectedModel];
    return this.resolveMetadata(
      modelConfig ? { config: modelConfig } : {},
      source,
      additionalMetadata
    );
  }
};
export {
  Dotprompt,
  PicoschemaParser,
  picoschema
};
